import { MapPoint, MultiPolygon } from "./map"

export interface ISectionDto {
  id: number
  venueId: number
  name: string
  sectionType?: string
  sectionAliases?: string[]
  aliases?: ISectionAliasDto[]
  shape?: IGeometry<GeometryType.MultiPolygon>
  updateShape?: string
  rows?: IRowDto[]
  definedCapacity?: number
  calculatedCapacity?: number
  locationScoreMedian?: number
  priceAreaNames?: PriceAreaNames
  priceGroupNames?: PriceGroupNames
  selected?: boolean
  capacity?: number
}

export interface IRowDto {
  id: number
  sectionId: number
  name: string
  rowType?: string
  rowAliases?: string[]
  shape?: IGeometry<GeometryType.MultiPolygon>
  updateShape?: string
  centerPoint?: IGeometry<GeometryType.Point>
  seats?: ISeatDto[]
  definedCapacity?: number
  calculatedCapacity?: number
  selected?: boolean
  rowsFromFront?: number
  locationScore?: number
  priceAreaNames?: PriceAreaNames
  priceGroupNames?: PriceGroupNames
  capacity?: number
}

export interface ISeatDto {
  id: number
  rowId: number
  sectionId: number
  name: string
  seatType?: string
  shape?: IGeometry<GeometryType.MultiPolygon>
  capacity?: number
  priceAreaName?: PriceAreaNames[number]
  priceGroupName?: PriceGroupNames[number]
  selected?: boolean
}

export interface ISectionAliasDto {
  name: string
  autoGenerated: boolean
}

export interface IGeometry<GeometryType> {
  type: GeometryType
  coordinates: GeometryType extends GeometryType.Point ? MapPoint : MultiPolygon[]
}

export enum GeometryType {
  Point = "Point",
  MultiPolygon = "MultiPolygon",
}

export type PriceAreaNames = string[]
export type PriceGroupNames = string[]

export interface ISection extends ISectionDto {
  multiPolygon: MultiPolygon
}
export interface IRow extends IRowDto {
  multiPolygon: MultiPolygon
}
