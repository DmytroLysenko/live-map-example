import React, { JSX } from 'react';
import { IMapItem as IMapItem$1, IVenueMapProps, DefaultExtraContentOptions as DefaultExtraContentOptions$1 } from '@onlocation/venue-map';

interface ISectionDto {
    id: number;
    venueId: number;
    name: string;
    sectionType?: string;
    sectionAliases?: string[];
    aliases?: ISectionAliasDto[];
    shape?: IGeometry<GeometryType.MultiPolygon>;
    updateShape?: string;
    rows?: IRowDto[];
    definedCapacity?: number;
    calculatedCapacity?: number;
    locationScoreMedian?: number;
    priceAreaNames?: PriceAreaNames;
    priceGroupNames?: PriceGroupNames;
    selected?: boolean;
    capacity?: number;
}
interface IRowDto {
    id: number;
    sectionId: number;
    name: string;
    rowType?: string;
    rowAliases?: string[];
    shape?: IGeometry<GeometryType.MultiPolygon>;
    updateShape?: string;
    centerPoint?: IGeometry<GeometryType.Point>;
    seats?: ISeatDto[];
    definedCapacity?: number;
    calculatedCapacity?: number;
    selected?: boolean;
    rowsFromFront?: number;
    locationScore?: number;
    priceAreaNames?: PriceAreaNames;
    priceGroupNames?: PriceGroupNames;
    capacity?: number;
}
interface ISeatDto {
    id: number;
    rowId: number;
    sectionId: number;
    name: string;
    seatType?: string;
    shape?: IGeometry<GeometryType.MultiPolygon>;
    capacity?: number;
    priceAreaName?: PriceAreaNames[number];
    priceGroupName?: PriceGroupNames[number];
    selected?: boolean;
}
interface ISectionAliasDto {
    name: string;
    autoGenerated: boolean;
}
interface IGeometry<GeometryType> {
    type: GeometryType;
    coordinates: GeometryType extends GeometryType.Point ? MapPoint : MultiPolygon[];
}
declare enum GeometryType {
    Point = "Point",
    MultiPolygon = "MultiPolygon"
}
type PriceAreaNames = string[];
type PriceGroupNames = string[];

type VenueMapLevel = "section" | "row";
type CallbackResponse = void | Promise<void>;
interface IMapItemIdentifies {
    sectionId?: ISectionDto["id"];
    rowId?: IRowDto["id"] | undefined;
    sectionName?: ISectionDto["name"];
    rowName?: IRowDto["name"] | undefined;
    aliases?: ISectionDto["sectionAliases"] | IRowDto["rowAliases"];
    sortOrder?: number;
}

interface IMapItem extends IMapItemIdentifies, Omit<IMapItem$1, "id" | "multiPolygon"> {
    rowTooltip?: JSX.Element;
    sectionTooltip?: JSX.Element;
}

type MapPoint = [number, number];
type MultiPolygon = Array<Array<MapPoint>>;
interface IMapProps extends Omit<IVenueMapProps, "items" | "background" | "hoverId" | "focusId" | "selectIds" | "onItemHover" | "onItemClick" | "onItemsSelect" | "defaultExtraContentOptions"> {
    /** Should be memorized */
    items?: IMapItem[];
    venueLayoutId?: number;
    level?: VenueMapLevel;
    token: string;
    hoveredItem?: IMapItemIdentifies;
    focusedItem?: IMapItemIdentifies;
    selectedItems?: IMapItemIdentifies[];
    onItemHover?: (item?: IMapItemIdentifies) => CallbackResponse;
    onItemClick?: (item: IMapItemIdentifies) => CallbackResponse;
    onItemsSelect?: (item: IMapItemIdentifies, items: IMapItemIdentifies[]) => CallbackResponse;
    onLevelChange?: (level: VenueMapLevel) => CallbackResponse;
    defaultExtraContentOptions?: false | DefaultExtraContentOptions;
}
type DefaultExtraContentOptions = DefaultExtraContentOptions$1 & {
    level?: false;
    levelWrapperClassName?: string;
};

declare const TPSMap: React.ForwardRefExoticComponent<Omit<IMapProps, "ref"> & React.RefAttributes<any>>;

export { type IMapItem, type IMapItemIdentifies, type IMapProps, TPSMap as default };
